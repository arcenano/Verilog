The design is split up into five distinct components, a CPU, an ALU, a decoder, microcode, and a testbench.

The CPU is the core of the device containing 16 4-bit registers, receiving a clock signal, a reset signal, and a 9-bit number from the testbench, and outputting the contents of register 15 back to the testbench.  The CPU also calls on and coordinates the microcode, decoder, and ALU (figure 1).  The CPU feeds the user input, clock, and reset to the microcode and receives instructions back from it.  It then passes a portion of the instructions, the clock, and reset to the decoder which returns a series of selectors and a carry in value to be used in the ALU.  The CPU also takes the memory locations from the microcode, finds the values at those locations, and passes those values to the ALU.  Once the ALU processes the data the CPU stores the result in the appropriate register if there is no skip flag, and it also copies the output to register 15 so that the testbench can see it.

The microcode receives the user input, clock, and reset flag front the CPU and outputs an opcode.  It first initializes an array of opcodes with all of the commands that we will execute.  It then increments a counter every clock cycle and sets the opcode at that array position to be the output to the CPU.  Once a reset flag is received it resets the counter and stays there until the reset flag is gone, restarting the code from the beginning. Each microcode starts with a command to set register 1 to 0, this is a dummy command that can be skipped (it does nothing) in case a skip is used right during reset.

The decoder is given the first 4 bits of the opcode coming from the microcode as well as the reset flag and uses a case statement to convert those to a 3-bit selector and initial carry in for the ALU, as well as skip and halt flags for the CPU and microcode (figure 5). The skipif instruction was changed so it skips if the number in the register is zero, as opposed to non-zero. This fit the microcode better to implement a counter. 

The ALU does all of the computing for the device.  It receives two 4-bit numbers, a 3-bit selector, a carry in, and outputs a 4-bit result.  The ALU is split into two main components, a 4-bit adder and a logic unit.  The adder is composed of four 1-bit adders and always adds both 4-bit numbers it receives together, but it uses two bits of the selector and the carry it to determine whether or not the second input will be positive, the 2â€™s complement for subtraction, or if the second input will be ignored.  This allows us to use the adder for addition, subtraction, increments, decrements, and copying.  The second component of the ALU is the logic unit which assigns three wires to the AND, OR, and XOR of the two inputs, and a fourth wire to just be the first input so that it can be used for the set command when combined with the CPU passing the source register number it receives from the microcode instead of the number stored at that register.  These four wires and two bits of the selector are then passed to a 4-way MUX where the correct output is chosen (figure 7).  The outputs from the logic unit and arithmetic unit are then both passed to a 2-way MUX where the last unused bit from the selector is used to determine which one to use for the final output back to the CPU (figure 8).

The test bench is used to instantiate the CPU and give it a clock signal, reset flag, and 9-bit number and receive a 4-bit output, as well as track all of the results.  The reason we use a 9-bit number is because each microcode has a different maximum number that it can use, so the first four bits are for the fibonacci code, the next three bits are for the adding code, and the final two bits are for the squaring code
